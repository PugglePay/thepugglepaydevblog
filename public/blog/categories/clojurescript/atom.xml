<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ClojureScript | PugglePay]]></title>
  <link href="http://devblog.pugglepay.com/blog/categories/clojurescript/atom.xml" rel="self"/>
  <link href="http://devblog.pugglepay.com/"/>
  <updated>2015-09-04T20:31:32+02:00</updated>
  <id>http://devblog.pugglepay.com/</id>
  <author>
    <name><![CDATA[dev]]></name>
    <email><![CDATA[dev@pugglepay.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ClojureScript: From Zero to Production (Part 2) - Integration Testing]]></title>
    <link href="http://devblog.pugglepay.com/blog/2015/09/04/clojurescript-from-zero-to-production-part-2-integration-testing/"/>
    <updated>2015-09-04T14:09:00+02:00</updated>
    <id>http://devblog.pugglepay.com/blog/2015/09/04/clojurescript-from-zero-to-production-part-2-integration-testing</id>
    <content type="html"><![CDATA[<p>If you are building a single page ClojureScript app, you might be
wondering how to write integration specs for it. By integration specs,
I mean tests that are run in the browser against a build that is as
close to the production app as possible.</p>

<p>In this post, I'll show you our setup to get autorunning integration
tests using <code>leiningen</code>, <code>clj-webdriver</code> and <code>speclj</code>.</p>

<!-- more -->


<h2>Goal</h2>

<p>The goal is to get the integration tests to be run every time we save
a file. Getting to run individual tests from the REPL was not a goal
here, because we did not want to force the developpers to have any
particular integration with their editors to get a good development
experience.</p>

<h2>Dependencies</h2>

<p>We need to run the tests in a browser that is "driveable" by
WebDriver. We chose <a href="https://github.com/ariya/phantomjs">phantomjs</a>
because it's easy to install and fast enough.</p>

<p>You can install it with <code>apt-get install phantomjs</code>, <code>brew install
phantomjs</code>, or your favourite package manager.</p>

<h2>Setting up your project.clj</h2>

<p>You'll need a new build target in your <code>project.clj</code>.</p>

<p>Note: this assumes you're using leiningen. If you're using boot, there
might be a better way to do all this.</p>

<p>Before adding integration tests, your <code>project.clj</code> should look something like this:</p>

<p>```clojure
(defproject my-project "0.1.0-SNAPSHOT"
  :description "FIXME: write this!"
  :url "http://example.com/FIXME"
  :license {:name "Eclipse Public License"</p>

<pre><code>        :url "http://www.eclipse.org/legal/epl-v10.html"}
</code></pre>

<p>  :dependencies [[org.clojure/clojure "1.7.0"]</p>

<pre><code>             [org.clojure/clojurescript "1.7.48"]]
</code></pre>

<p>  :plugins [[lein-cljsbuild "1.0.6"]]</p>

<p>  :source-paths ["src"]</p>

<p>  :resource-paths ["resources" "resources/public"]</p>

<p>  :cljsbuild
  {:builds
   {:main {:source-paths ["src"]</p>

<pre><code>       :compiler {:output-to "resources/public/out/my_project.js"
                  :optimizations :advanced
                  :main my-project.core
                  :pretty-print false}}}}
</code></pre>

<p>  :profiles
  {:dev {:dependencies [[figwheel "0.3.8"]</p>

<pre><code>                    [org.clojure/tools.nrepl "0.2.10"]]
     :plugins [[lein-figwheel "0.3.8"]]

     :cljsbuild
     {:builds
      {:main {:source-paths ["src"]
              :figwheel {:on-jsload "my-project.core/on-js-reload"}
              :compiler {:main my-project.core
                         :optimization :none
                         :asset-path "out"
                         :output-to "resources/public/out/my_project.js"
                         :output-dir "resources/public/out"
                         :source-map-timestamp true}}}}

     :figwheel {:css-dirs ["resources/public/css"]}

     :clean-targets ^{:protect false} ["resources/public/js/compiled" "target"]}})
</code></pre>

<p>```</p>

<p>Let's add a new profile for integrations specs with all the extra
dependencies we need:</p>

<p>```clojure
   :integration {:dependencies [[compojure "1.3.4"]</p>

<pre><code>                            [ring/ring-jetty-adapter "1.4.0-RC1"]
                            [clj-webdriver "0.6.1"]
                            [speclj "3.3.1"]]

             :plugins [[speclj "3.2.0"]]

             :test-paths ["src" "spec"]}
</code></pre>

<p>```</p>

<p>If we dissect the above, we're adding compojure and a ring jetty
adapter so we can serve our compile app to a browser, <code>clj-webdriver</code>
will be interacting with the browser and <code>speclj</code> will be used to run
the test. <code>speclj</code> could be replace with any other testing library.</p>

<p>We'll put our tests in a separate <code>spec</code> folder at the root of the
project, that's why we add it to the test paths.</p>

<h2>Setup the tests</h2>

<p>To run the integration tests, and every time we save one of the source
files, we need the following steps:</p>

<ul>
<li><p>Compile the ClojureScript app</p></li>
<li><p>Start a webserver to serve the app</p></li>
<li><p>Setup a WebDriver that can visit the app served by the webserver.</p></li>
</ul>


<p>Using <code>speclj</code>, this will mean adding a bunch of wrappers around our
actual specs.</p>

<p>Let's start with writting a webserver that will help us serve our app
in <code>spec/my_project/spec_utils/server.clj</code>:</p>

<p>```clojure
(ns my.project.spec-utils.server
  (:require [clojure.java.io :as io]</p>

<pre><code>        [compojure.core :refer [routes GET defroutes]]
        [compojure.route :refer [resources]]
        [compojure.handler :refer [api]]
        [ring.adapter.jetty :refer [run-jetty]]))
</code></pre>

<p>(defroutes http-handler
  (resources "/" :root "resources/public"))</p>

<p>(defn start [port]
  (run-jetty http-handler {:port port :join? false}))
```</p>

<p>This is a very simple server that will server all static files from
the <code>resources/public</code> folder.</p>

<p>Next, let's add a compiler in <code>spec/my_project/spec_utils/compiler.clj</code>:</p>

<p>```clojure
(ns my-project.spec-utils.compiler
  (:require [cljs.build.api]))</p>

<p>(defn build-cljs!
  "Builds cljs for integration specs"
  []
  (println "building cljs")
  (cljs.build.api/build
   "src"
   {:main 'my-project.core</p>

<pre><code>:output-to "resources/public/integration/main.js"
:output-dir "resources/public/integration"
:asset-path "integration"
:optimizations :none
:static-fns true ; for phantomjs/safari
}))
</code></pre>

<p>```</p>

<p>And finally, we'll need the phantomjs driver (<code>spec/my_project/spec_utils/phantomjs.clj</code>):</p>

<p>```clojure
(ns my-project.spec-utils.phantomjs
  (:import [org.openqa.selenium.phantomjs PhantomJSDriver]</p>

<pre><code>       [org.openqa.selenium.remote DesiredCapabilities]))
</code></pre>

<p>(defn driver []
  (PhantomJSDriver.
   (doto (DesiredCapabilities.)</p>

<pre><code> (.setCapability "phantomjs.cli.args"
                 (into-array String ["--ignore-ssl-errors=true"
                                     "--webdriver-loglevel=warn"])))))
</code></pre>

<p>```</p>

<p>There's a bit of Java incantations here to parametrize the
driver. Webdriver is using the Java version of the Selenium webdriver,
so if you want to configure this further you can look into Selenium's
docs.</p>

<p>Finally, let's create a single-entry utils file
<code>spec/my_project/spec_utils.clj</code> to combine all of the above:</p>

<p>```clojure
(ns my-project.spec-utils
  (:require [clj-webdriver.taxi :as t]</p>

<pre><code>        [clj-webdriver.driver :as driver]
        [my-project.spec-utils.server :as server]
        [my-project.spec-utils.compiler :as compiler]
        [my-project.spec-utils.phantomjs :as phantomjs]))
</code></pre>

<p>(def build-cljs! compiler/build-cljs!)</p>

<p>(defn with-server
  "Start a server to host the js files"
  [specs]
  (println "starting server")
  (let [svr (server/start 10555)]</p>

<pre><code>(try (specs) (finally (.stop svr)))))
</code></pre>

<p>(defn with-webdriver
  "setup selenium webdriver"
  [specs]
  (println "starting webdriver")
  (try</p>

<pre><code>(let [driver (driver/init-driver {:webdriver (phantomjs/driver)})]
  (t/implicit-wait driver 3000)
  (t/set-driver! driver)
  (specs))
(finally (t/quit))))
</code></pre>

<p>```</p>

<p>Then we're ready to write our first spec! In
<code>spec/my_project/core_spec.clj</code>:</p>

<p>```clojure
(ns my-project.core-spec
  (:require [clj-webdriver.taxi :as taxi]</p>

<pre><code>        [speclj.core :refer :all]
        [my-project.spec-utils :as utils]))
</code></pre>

<p>(describe "the whole thing"
  (before-all (utils/build-cljs!))
  (around-all [specs] (utils/with-server specs))
  (around-all [specs] (utils/with-webdriver specs))</p>

<p>  (describe "index page"</p>

<pre><code>(it "works"
  (taxi/to "http://localhost:10555/")
  (taxi/take-screenshot :file "./screenshot.png")
  (should-contain "hello!" (taxi/text "h2")))))
</code></pre>

<p>```</p>

<h2>Result</h2>

<p>You can find an example of minimal setup here: <a href="https://github.com/Jell/cljs-autospec-example">https://github.com/Jell/cljs-autospec-example</a>.</p>

<p>This follows closelly the instructions in this blogpost.</p>

<h2>Extra tips</h2>

<p>In our setup, we duplicate the compiler options several times: twice
in the <code>project.clj</code> and once in <code>compiler.clj</code>.</p>

<p>This can be tedious and error-prone if you have <code>:libs</code> or
<code>:foreign-libs</code> in your config.</p>

<p>To avoid this, you can move the common compiler options to a separate
<code>config/compiler.clj</code> file that you then read in your <code>project.clj</code>
and <code>compiler.clj</code> files.</p>

<p>Do do that in the <code>project.clj</code>, use an unquoted expression:</p>

<p><code>clojure
{:compiler ~(read-string (slurp "config/compiler.clj"))}
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ClojureScript: from zero to production (Part 1)]]></title>
    <link href="http://devblog.pugglepay.com/blog/2015/08/12/clojurescript-from-zero-to-production-part-1/"/>
    <updated>2015-08-12T13:22:00+02:00</updated>
    <id>http://devblog.pugglepay.com/blog/2015/08/12/clojurescript-from-zero-to-production-part-1</id>
    <content type="html"><![CDATA[<p>A few weeks ago, we've released our first user-facing ClojureScript
app. We developed it over the course of couple of months, starting
from scratch.</p>

<p>We had previously launched a couple of non-critical Clojure apps (our
slack bot, some testing tools), most of our projects being written in
Ruby.</p>

<!-- more -->


<h2>Motivation</h2>

<p>PugglePay is a payment company, and we wanted to provide a page for
our users to see their unpaid bills and get an overview of the last
few transactions.</p>

<p>After investigating our options, we decided that we should start a new
separate project that access all relevant info from our backend via an
API, then present it to the user in a nicely structured way.</p>

<p>We've also decided that we did not want to have a user account and a
system of login, instead access to the page should be through one-time
links sent to the user along with each payment information.</p>

<p>We therefore realised that we could have this app as a single-page
JavaScript app. JavaScript
<a href="https://www.destroyallsoftware.com/talks/wat">sucks</a>, so we wanted
to find a better way to build client-rich apps. Therefore ClojureScript.</p>

<p>We chose ClojureScript because we knew the semantics of Clojure were
very good, and given our knowledge and experience, this was the best
fit.</p>

<h2>Our current setup</h2>

<p>Our stack consists of the following libraries:</p>

<ul>
<li><a href="https://github.com/bhauman/lein-figwheel">figwheel</a></li>
<li><a href="https://github.com/reagent-project/reagent">reagent</a> (and therefore react)</li>
<li><a href="https://github.com/Day8/re-frame">re-frame</a> (most epic README ever btw)</li>
<li><a href="https://github.com/ckirkendall/kioo">kioo</a></li>
<li><a href="http://speclj.com/">speclj</a></li>
</ul>


<p><a href="https://github.com/bhauman/lein-figwheel">Figwheel</a> is I think the
key to the success of this app. It's trivial to setup, and you get
interactive development without any particular editor support.</p>

<p>This is very important, compared to the usual REPL-driven development
of Clojure projects. This means that beginners can get started without
having to setup anything, and focus on the code before focusing on
setting up their environment.</p>

<p>I believe the second important factor was using
<a href="https://github.com/ckirkendall/kioo">Kioo</a>. Because the templates are
made of pure HTML and are rendered using composable transformations,
developers and designers were able to work in parallel without
interfering with each other and communicating using HTML as
lingua-franca.</p>

<p>This made the development very smooth.</p>

<p>One weak point was testing setup, which ended up being a bit too much
of a hassle to setup. New tools are now surfacing that would make
things smoother in the future
(<a href="https://github.com/bhauman/devcards">devcards</a> maybe?).</p>

<h2>Lessons learned</h2>

<p>I'll just list a few here, more to come in later posts.</p>

<h3>DOM manipulation is slow, React is awesome</h3>

<p>In the first version of our app, we used
<a href="https://github.com/ckirkendall/enfocus">enfocus</a> instead of
<a href="https://github.com/ckirkendall/kioo">kioo</a>, and did not use React at
all. This made the app much too slow when testing on the IPhone, so we
re-wrote it using react.</p>

<p>Fortunatelly, we had already structured the app around a single atom
holding all our state, so this was an easy transition.</p>

<h3>The iphone 4 javascript engine is utterly broken</h3>

<p>We tracked down an incredible bug when using hashing functions that
only happened on iphone 4 when NOT using a web inspector.  You can
read about it here:
<a href="http://dev.clojure.org/jira/browse/CLJS-1380">http://dev.clojure.org/jira/browse/CLJS-1380</a></p>

<p>TL;DR: the JIT compiler has broken inlining of bit operations on the
iPhone 4 (note: not on the iphone 4S! only specifically using the
hardware version of the iphone 4). The solution: use <code>try ... catch</code>
to disable JIT compiling for functions doing bit operations.</p>

<p>Separate blog post coming soon!</p>

<h3>re-frame is good</h3>

<p>Once you get around to it, it's a very small library that will help
you organize the flow of your app. We started without, and all-in-all
it was not bad, except for the part where we had to deal with side
effects or query the app state in different in different ways and
places.</p>

<p>But still ended up with a structure that was very similar to re-frame,
except less good, and adhering to the re-frame conventions helped us
better structure everything with a linear flow of data.</p>

<p>Separate blog post coming soon!</p>

<h3>tracking errors is not a bad idea</h3>

<p>We use <a href="https://app.honeybadger.io/">Honeybadger</a> to track errors on
the page (that's what we were using for our Rails app to begin
with). We were afraid it would end up being very noisy, but we
actually get only very few errors related to loading issues (and we
plan to fix those).</p>

<h3>Write integration specs in Clojure</h3>

<p>The way we write integrations tests is to have a setup phase in our
specs where we compile our app from withing Clojure using
<code>cljs.build.api/build</code>, start a compojure / jetty server that serves
the app and stubs the API the app talks to, and run the specs using
<code>clj-webdriver</code> and phantomjs.</p>

<p>Separate blog post coming soon!</p>

<h2>Conclusion</h2>

<p>We have been live for a few weeks now, and everything runs
smoothly. Everybody at the office has contributed to the project, have
a good understanding of its inner workings, and is satisfied with the
result. All in all, a pretty good experience.</p>
]]></content>
  </entry>
  
</feed>
