<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[PugglePay]]></title>
  <link href="http://devblog.pugglepay.com/atom.xml" rel="self"/>
  <link href="http://devblog.pugglepay.com/"/>
  <updated>2013-05-03T21:41:59+02:00</updated>
  <id>http://devblog.pugglepay.com/</id>
  <author>
    <name><![CDATA[The Puggles]]></name>
    <email><![CDATA[dev@pugglepay.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Torquebox or: How I Learned to Stop Worrying and Love the JVM]]></title>
    <link href="http://devblog.pugglepay.com/blog/2013/05/03/torquebox-or-how-i-learned-to-stop-worrying-and-love-the-jvm/"/>
    <updated>2013-05-03T10:42:00+02:00</updated>
    <id>http://devblog.pugglepay.com/blog/2013/05/03/torquebox-or-how-i-learned-to-stop-worrying-and-love-the-jvm</id>
    <content type="html"><![CDATA[<p>So here is the thing. As a DevOp, SysAdmin is a PITA. Time spent
tweaking the servers to add such or such service is time not spent
actually producing value.</p>

<p>At PugglePay, we try to be agile and always look at the trade-offs
that are involved in every decision we make. So as we started
developing our product, we decided to go with the easy and fast track,
and that meant Amazon, Rails and MySQL.</p>

<p>Unfortunately, easy does not necessary mean simple, so we kept using
the same tools to the point where easy became complex. It was time
for us to do something difficult which was to use more tools and turn our
architecture simple again.</p>

<!-- more -->


<p>The difficult thing for us was to move out of our comfort zone because
our comfort zone was a dangerous place (remember the frog being slowly
boiled to death).</p>

<h2>Our problem:</h2>

<ul>
<li><p>We needed queues. We kept on postponing using them because we wanted
to Keep It Simpleâ„¢, but simple meant using queues.</p></li>
<li><p>We needed daemons. Stuff that run non stop, and that get updated
after each deploy.</p></li>
<li><p>We needed scheduled jobs. We used cron for that, but that meant
the application and the server were tightly coupled. Not simple!
(but easy)</p></li>
</ul>


<p>If we look at all of the above, the easy solution would have been to
add a message processing lib like sidekiq, a short capistrano script
to redeploy our services and keep on using cron for recurring tasks.
But here comes the trick:</p>

<ul>
<li>We are going to need clustering. And we want all of the above to be
clustered.</li>
</ul>


<p>So as any good developer, we googled &#8220;rails queues cron clustering&#8221;
and found <a href="http://torquebox.org/">TorqueBox</a>.</p>

<h2>TorqueBox</h2>

<p>The idea of TorqueBox is to add a layer of abstraction between the
server and your application. It&#8217;s like you are building a city, and
TorqueBox offers to provide the sewer system, running water,
electricity and the Internet so that you can focus on the city
planning.</p>

<p>In practice, that meant webserver, messaging, recurring jobs, and
daemons out of the box, and the only SysAdmin we have to take care of
is to get TorqueBox running.</p>

<p>Wow. That looked exactly like what we needed. Only downside: it runs on
JRuby. Which means JVM. And we had zero knowledge.</p>

<p>But the concept was just too good to be so easily dismissed because of our
own lack of knowledge. It would be difficult for us, but it could
become easy on the long run.</p>

<h2>Investigation</h2>

<p>So we started our investigation. The first step was to migrate our app
to JRuby. First downside: we got really slow tests. So that&#8217;s the
first thing we had to improve.</p>

<p>The solution was to use <a href="https://github.com/sporkrb/spork">Spork</a> and
NailGun. What we got are fast enough tests. It&#8217;s slower than with MRI
(10% slower on average), but good enough.</p>

<p>So running on JRuby: check! Next step was to get the app running
locally on TorqueBox. Roughly, that meant:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>gem install torquebox
</span><span class='line'>torquebox run
</span><span class='line'>torquebox deploy
</span></code></pre></td></tr></table></div></figure>


<p>Boom. Trivial. Now let&#8217;s deploy to Amazon. Well, there&#8217;s a
<a href="https://github.com/torquebox/chef-cookbooks">chef recipe</a>. It
requires some extra work to get clustering going because Amazon does
not support multicasting (for automatic discovery of new nodes). Well,
clustering is for later, and for sure we&#8217;re going to solve that
problem. So getting TorqueBox to run on Amazon: check!</p>

<p>Now let&#8217;s deploy. Cool, there&#8217;s a
<a href="https://rubygems.org/gems/torquebox-capistrano-support">Capistrano recipe</a>!
We already used capistrano, so that was easy. Boom! Deploying to
TorqueBox: check!</p>

<p>Sweet! Now lets deploy again! Yay, it works! And again! Yay! And
again! Oups&#8230; Nothing works anymore. Well, we knew exactly nothing
about JRuby, the JVM or TorqueBox, so it took us a week to find out
that after a redeploy the connections to the database were only closed
after Garbage Collection, but garbage collection came too late in our
case.</p>

<p>So the solution was to add an <code>at_exit</code> hook that took care of closing
all connections after redeploy.</p>

<p>We also realized that we do not get zero-downtime deploy when
deploying to TorqueBox. That&#8217;s sad, because we are going to need it in
the future. After googling a little more, we found out that this is a
feature coming with the next release. Fair enough.</p>

<p>So after a couple of weeks of research and testing, we were confident
enough that TorqueBox would make our system much easier to maintain in
the future, and decided that the pros were bigger than the cons.</p>

<p>So we took a leap of faith and deployed the whole thing in production.</p>

<h2>Running in production</h2>

<p>It went pretty smoothly at first, but after a couple of deploy we got
a &#8220;PermGen out of memory&#8221; error. WTF is that?</p>

<p>Well, that&#8217;s a story for another post. Long story short, closing the
DB connections was not enough because some references were being kept
that prevented the JRuby runtimes from being garbage collected after
each deploy. Also <code>jvisualvm</code> is an awesome tool that lets you inspect
a running JVM in realtime.</p>

<p>We have been running TorqueBox in production for a couple of weeks now,
and we are getting more familiar with it everyday. Our architecture is
much simpler, and the difficult bump we had to overcome is behind us.
So in the end, we believe that we have made the right choice.</p>

<p>But I think it is important to know that this was not a totally
painless migration. We had to learn about the JVM, how its garbage
collection works, which tool to use and which flags to set, while
making sure our development speed was not too much impacted by the
change. For us, it was worth it because we needed a better
infrastructure, and we did not want to rely on too many components.</p>

<h2>Conclusion</h2>

<p>Pros > Cons, lots of new things to learn, but the end
result is a simpler architecture.</p>

<p>We&#8217;d love to share more of what we know, but we&#8217;d love even more to
acquire knowledge from others. So if you have some experience with
TorqueBox, please get in touch!</p>

<hr />


<div>
   <div style="float: left;">
      <img alt="avatar" src="http://www.gravatar.com/avatar/4eed77cef649100303e38c7c05689eb8.png" />
   </div>
<div style="float: left; margin-left: 20px;">
<p style="font-wight: bold;">Author: Jean-Louis Giordano
   <br />
   email: <a href="mailto: jean-louis@pugglepay.com">jean-louis@pugglepay.com</a>
   <br />
   <a href="https://twitter.com/jellismymind" class="twitter-follow-button" data-show-count="false" data-size="large">Follow @jellismymind</a>
   <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
</p>
</div>
</div>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[spork_and_nailgun.el]]></title>
    <link href="http://devblog.pugglepay.com/blog/2013/05/02/spork-and-nailgun-dot-el/"/>
    <updated>2013-05-02T23:31:00+02:00</updated>
    <id>http://devblog.pugglepay.com/blog/2013/05/02/spork-and-nailgun-dot-el</id>
    <content type="html"><![CDATA[<p>We recently made the shift to TorqueBox here at PugglePay, and that
meant moving from MRI to JRuby. I order to cope with the slow start-up
induced by the JVM we started using spork and nailgun for running our
tests.</p>

<p><a href="https://github.com/sporkrb/spork">Spork</a> preloads instances of your
application for you to have faster startup for your tests. And nailgun
(wich comes with JRuby) is a lower level tool to have jvm instances
ready to go.</p>

<p>Both of them stay alive between test runs and can get &#8220;corrupted&#8221;. You
also need to restart spork every time you change something that is
outside what it reloads between each test (blueprints for example in
our case).</p>

<p>So we (eq me and Jean-Louis) decided to spend an hour to make this a
bit easier. With the answer to all technical problems!</p>

<!-- more -->


<h3><a href="https://github.com/PugglePay/spork-and-nailgun.el">An Emacs Plugin</a></h3>

<p>So install it (with <a href="https://github.com/dimitri/el-get">el-get</a> perhaps) and bind a key (ex <code>C-c C-l</code>) to &#8216;sang-start-all and run it.</p>

<ul>
<li>It will kill any running instances of spork and nailgun you have
running (by looking up the port they are listening to),</li>
<li>Jump to the root of the project your currently editing in and
activate the right rvm env,</li>
<li>Start upp Spork and nailgun in separate buffers.</li>
</ul>


<p>The spork buffer will popup and it can have some useful information if
you have some errors.</p>

<p><a href="http://imgur.com/RozzIIv"><img src="http://i.imgur.com/RozzIIv.png" title="Hosted by imgur.com"/></a></p>

<p>Now your ready to run your tests with <a href="https://github.com/pezra/rspec-mode"><code>C-c , v</code></a></p>

<p>This plugin works well for our workflow so <a href="https://github.com/PugglePay/spork-and-nailgun.el">try it out</a> yourself.</p>

<hr />


<div>
   <div style="float: left;">
      <img alt="avatar" src="https://secure.gravatar.com/avatar/d7e5aaa6813cde9cbd0005a2cf2b56f1?d=https://d3levm2kxut31z.cloudfront.net/assets/blank-mugshot-112e2e92d74b7344b8be3630bbccc5da.png" />
   </div>
<div style="float: left; margin-left: 20px;">
<p style="font-wight: bold;">Author: Patrik KÃ¥rlin
   <br />
   email: <a href="mailto: patrik@pugglepay.com">patrik@pugglepay.com</a>
   <br />
   <a href="https://twitter.com/patrik_karlin" class="twitter-follow-button" data-show-count="false" data-size="large">Follow @patrik_karlin</a>
   <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
</p>
</div>
</div>



]]></content>
  </entry>
  
</feed>
